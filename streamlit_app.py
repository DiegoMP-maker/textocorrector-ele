import streamlit as st
import json
import gspread
import requests
import re
from google.oauth2.service_account import Credentials
from datetime import datetime
from openai import OpenAI
from io import BytesIO

# --- 1. CONFIGURACI√ìN DE CLAVES SEGURAS ---
openai_api_key = st.secrets["OPENAI_API_KEY"]
elevenlabs_api_key = st.secrets["ELEVENLABS_API_KEY"]
elevenlabs_voice_id = st.secrets["ELEVENLABS_VOICE_ID"]

# --- 2. CONEXI√ìN A GOOGLE SHEETS ---
scope = [
    "https://spreadsheets.google.com/feeds",
    "https://www.googleapis.com/auth/drive"
]
creds_dict = json.loads(st.secrets["GOOGLE_CREDENTIALS"])
creds = Credentials.from_service_account_info(creds_dict, scopes=scope)
client_gsheets = gspread.authorize(creds)

# IDs de los documentos
CORRECTIONS_DOC_ID = "1GTaS0Bv_VN-wzTq1oiEbDX9_UdlTQXWhC9CLeNHVk_8"  # Historial_Correcciones_ELE
TRACKING_DOC_ID    = "1-OQsMGgWseZ__FyUVh0UtYVOLui_yoTMG0BxxTGPOU8"  # Seguimiento

# --- Abrir documento de correcciones (Historial_Correcciones_ELE) ---
try:
    corrections_sheet = client_gsheets.open_by_key(CORRECTIONS_DOC_ID).sheet1
    st.success("‚úÖ Conectado a Historial_Correcciones_ELE correctamente.")
except Exception as e:
    st.error(f"‚ùå Error al conectar con Historial_Correcciones_ELE: {e}")
    st.stop()

# --- Verificar y preparar documento de seguimiento ---
try:
    tracking_doc = client_gsheets.open_by_key(TRACKING_DOC_ID)
    hojas = [hoja.title for hoja in tracking_doc.worksheets()]
    
    # Verificar si existe la hoja Seguimiento
    try:
        tracking_sheet = tracking_doc.worksheet("Seguimiento")
        st.success("‚úÖ Conectado a hoja Seguimiento correctamente.")
    except gspread.exceptions.WorksheetNotFound:
        # Crear la hoja si no existe
        tracking_sheet = tracking_doc.add_worksheet(title="Seguimiento", rows=100, cols=10)
        # A√±adir encabezados a la hoja
        headers = ["Nombre", "Nivel", "Fecha", "Errores Gram√°tica", "Errores L√©xico", 
                   "Errores Puntuaci√≥n", "Errores Estructura", "Total Errores", "Consejo Final"]
        tracking_sheet.append_row(headers)
        st.success("‚úÖ Hoja 'Seguimiento' creada y preparada correctamente.")
except Exception as e:
    st.warning(f"‚ö†Ô∏è Advertencia con documento de Seguimiento: {e}")

# --- 3. INTERFAZ ---
st.title("üìù Textocorrector ELE (por Diego)")
st.markdown("Corrige tus textos escritos y guarda autom√°ticamente el feedback.")

with st.form("formulario"):
    nombre = st.text_input("¬øC√≥mo te llamas?")
    nivel = st.selectbox("¬øCu√°l es tu nivel?", [
        "Nivel principiante (A1-A2)",
        "Nivel intermedio (B1-B2)",
        "Nivel avanzado (C1-C2)"
    ])
    idioma = st.selectbox("Selecciona lenguaje para la correcci√≥n", ["Espa√±ol", "Franc√©s", "Ingl√©s"])
    texto = st.text_area("Escribe tu texto para corregirlo:", height=250)
    enviar = st.form_submit_button("Corregir")

# Funci√≥n para obtener JSON de la IA con reintentos
def obtener_json_de_ia(system_msg, user_msg, max_retries=3):
    client = OpenAI(api_key=openai_api_key)
    messages = [
        {"role": "system", "content": system_msg},
        {"role": "user", "content": user_msg}
    ]
    
    for attempt in range(max_retries):
        try:
            response = client.chat.completions.create(
                model="gpt-4-turbo",
                temperature=0.5,
                messages=messages
            )
            raw_output = response.choices[0].message.content

            try:
                data_json = json.loads(raw_output)
                return raw_output, data_json
            except json.JSONDecodeError:
                # Intenta extraer JSON usando regex
                match_json = re.search(r"\{.*\}", raw_output, re.DOTALL)
                if match_json:
                    json_str = match_json.group(0)
                    try:
                        data_json = json.loads(json_str)
                        return raw_output, data_json
                    except json.JSONDecodeError:
                        pass

                # Si a√∫n no hay JSON v√°lido, pide al modelo que corrija
                if attempt < max_retries - 1:
                    messages.append({
                        "role": "system",
                        "content": (
                            "Tu respuesta anterior no cumpli√≥ el formato JSON requerido. "
                            "Por favor, responde √öNICAMENTE en JSON v√°lido con la estructura solicitada. "
                            "No incluyas texto extra, backticks, ni marcadores de c√≥digo fuente."
                        )
                    })
        except Exception as e:
            st.warning(f"Intento {attempt+1}: Error en la API de OpenAI: {e}")
            if attempt == max_retries - 1:
                raise

    raise ValueError("No se pudo obtener un JSON v√°lido tras varios reintentos.")

# --- 4. CORREGIR TEXTO CON IA Y JSON ESTRUCTURADO ---
if enviar and nombre and texto:
    with st.spinner("Corrigiendo con IA‚Ä¶"):
        # Instrucciones para el modelo de IA
        system_message = f"""
Eres Diego, un profesor experto en ELE.
Cuando corrijas un texto, DEBES devolver la respuesta √∫nicamente en un JSON v√°lido, sin texto adicional, con la siguiente estructura EXACTA:

{{
  "saludo": "string",                // en {idioma}
  "tipo_texto": "string",            // en {idioma}
  "errores": {{
       "Gram√°tica": [
           {{
             "fragmento_erroneo": "string",
             "correccion": "string",
             "explicacion": "string"  // Explicaci√≥n en {idioma}
           }}
           // m√°s errores de Gram√°tica (o [] si ninguno)
       ],
       "L√©xico": [
           {{
             "fragmento_erroneo": "string",
             "correccion": "string",
             "explicacion": "string"  // Explicaci√≥n en {idioma}
           }}
       ],
       "Puntuaci√≥n": [
           {{
             "fragmento_erroneo": "string",
             "correccion": "string",
             "explicacion": "string"  // Explicaci√≥n en {idioma}
           }}
       ],
       "Estructura textual": [
           {{
             "fragmento_erroneo": "string",
             "correccion": "string",
             "explicacion": "string"  // Explicaci√≥n en {idioma}
           }}
       ]
  }},
  "texto_corregido": "string",       // en {idioma}
  "consejo_final": "string",         // SOLO esta parte va en espa√±ol, independientemente del idioma seleccionado
  "fin": "Fin de texto corregido."
}}

INSTRUCCIONES IMPORTANTES:
1. Las categor√≠as "Gram√°tica", "L√©xico", "Puntuaci√≥n", "Estructura textual" siempre van en espa√±ol, no las traduzcas.
2. "saludo", "tipo_texto", "texto_corregido" y TODAS las explicaciones de errores deben estar en el idioma: {idioma}
3. SOLO "consejo_final" va SIEMPRE en espa√±ol, independientemente del idioma seleccionado.
4. No traduzcas ni "fragmento_erroneo" ni "correccion", deben mantener el idioma del texto original.

No devuelvas ning√∫n texto extra fuera de este JSON.
"""
        user_message = f"""
Texto del alumno:
\"\"\"
{texto}
\"\"\"
Nivel: {nivel}
Nombre del alumno: {nombre}
Idioma de correcci√≥n: {idioma}

IMPORTANTE: Recuerda que la correcci√≥n debe estar en el idioma seleccionado ({idioma}). 
El "saludo", "tipo_texto", "texto_corregido" y todas las explicaciones de errores deben estar en {idioma}. 
Solo el "consejo_final" va siempre en espa√±ol.
"""

        try:
            raw_output, data_json = obtener_json_de_ia(system_message, user_message, max_retries=3)

            # Extraer campos del JSON
            saludo = data_json.get("saludo", "")
            tipo_texto = data_json.get("tipo_texto", "")
            errores_obj = data_json.get("errores", {})
            texto_corregido = data_json.get("texto_corregido", "")
            consejo_final = data_json.get("consejo_final", "")
            fin = data_json.get("fin", "")

            # Adaptamos las cabeceras seg√∫n el idioma seleccionado
            headers_by_language = {
                "Espa√±ol": {
                    "saludo": "Saludo", 
                    "tipo_texto": "Tipo de texto y justificaci√≥n", 
                    "errores": "Errores detectados",
                    "texto_corregido": "Texto corregido completo", 
                    "consejo_final": "Consejo final (en espa√±ol)"
                },
                "Franc√©s": {
                    "saludo": "Salutation", 
                    "tipo_texto": "Type de texte et justification", 
                    "errores": "Erreurs d√©tect√©es",
                    "texto_corregido": "Texte corrig√© complet", 
                    "consejo_final": "Conseil final (en espagnol)"
                },
                "Ingl√©s": {
                    "saludo": "Greeting", 
                    "tipo_texto": "Text type and justification", 
                    "errores": "Detected errors",
                    "texto_corregido": "Complete corrected text", 
                    "consejo_final": "Final advice (in Spanish)"
                }
            }
            
            h = headers_by_language.get(idioma, headers_by_language["Espa√±ol"])

            st.subheader(h["saludo"])
            st.write(saludo)
            st.subheader(h["tipo_texto"])
            st.write(tipo_texto)
            st.subheader(h["errores"])
            if not errores_obj:
                if idioma == "Espa√±ol":
                    st.write("No se han detectado errores.")
                elif idioma == "Franc√©s":
                    st.write("Aucune erreur d√©tect√©e.")
                else:  # Ingl√©s
                    st.write("No errors detected.")
            else:
                for categoria in ["Gram√°tica", "L√©xico", "Puntuaci√≥n", "Estructura textual"]:
                    lista_errores = errores_obj.get(categoria, [])
                    st.markdown(f"**{categoria}**")
                    if not lista_errores:
                        if idioma == "Espa√±ol":
                            st.write("  - Sin errores en esta categor√≠a.")
                        elif idioma == "Franc√©s":
                            st.write("  - Pas d'erreurs dans cette cat√©gorie.")
                        else:  # Ingl√©s
                            st.write("  - No errors in this category.")
                    else:
                        for err in lista_errores:
                            # Adaptamos las etiquetas seg√∫n el idioma
                            if idioma == "Espa√±ol":
                                st.write(f"  - Fragmento err√≥neo: {err.get('fragmento_erroneo','')}")
                                st.write(f"    Correcci√≥n: {err.get('correccion','')}")
                                st.write(f"    Explicaci√≥n: {err.get('explicacion','')}")
                            elif idioma == "Franc√©s":
                                st.write(f"  - Fragment erron√©: {err.get('fragmento_erroneo','')}")
                                st.write(f"    Correction: {err.get('correccion','')}")
                                st.write(f"    Explication: {err.get('explicacion','')}")
                            else:  # Ingl√©s
                                st.write(f"  - Erroneous fragment: {err.get('fragmento_erroneo','')}")
                                st.write(f"    Correction: {err.get('correccion','')}")
                                st.write(f"    Explanation: {err.get('explicacion','')}")
                    st.write("---")

            st.subheader(h["texto_corregido"])
            st.write(texto_corregido)

            st.subheader(h["consejo_final"])
            st.write(consejo_final)
            st.write(fin)

            # Guardar en Historial_Correcciones_ELE
            fecha = datetime.now().strftime("%Y-%m-%d %H:%M")
            corrections_sheet.append_row([nombre, nivel, idioma, fecha, texto, raw_output])
            st.success("‚úÖ Correcci√≥n guardada en Historial_Correcciones_ELE.")

            # --- CONTEO DE ERRORES ---
            num_gramatica = len(errores_obj.get("Gram√°tica", []))
            num_lexico = len(errores_obj.get("L√©xico", []))
            num_puntuacion = len(errores_obj.get("Puntuaci√≥n", []))
            num_estructura = len(errores_obj.get("Estructura textual", []))
            total_errores = num_gramatica + num_lexico + num_puntuacion + num_estructura

            # --- GUARDAR SEGUIMIENTO EN EL DOCUMENTO "Seguimiento" ---
            try:
                datos_seguimiento = [
                    nombre,
                    nivel,
                    fecha,
                    num_gramatica,
                    num_lexico,
                    num_puntuacion,
                    num_estructura,
                    total_errores,
                    consejo_final
                ]
                
                # Intenta aprovechar la variable tracking_sheet que definimos al inicio
                try:
                    tracking_sheet.append_row(datos_seguimiento)
                    st.success(f"‚úÖ Estad√≠sticas guardadas en hoja de Seguimiento.")
                    
                    # Mostrar resumen de errores
                    st.subheader("Resumen de errores")
                    col1, col2, col3, col4 = st.columns(4)
                    with col1:
                        st.metric("Gram√°tica", num_gramatica)
                    with col2:
                        st.metric("L√©xico", num_lexico)
                    with col3:
                        st.metric("Puntuaci√≥n", num_puntuacion)
                    with col4:
                        st.metric("Estructura", num_estructura)
                    st.metric("Total errores", total_errores)
                    
                except NameError:
                    # Si tracking_sheet no est√° definido, intentamos recuperarlo
                    tracking_doc = client_gsheets.open_by_key(TRACKING_DOC_ID)
                    try:
                        tracking_sheet = tracking_doc.worksheet("Seguimiento")
                    except gspread.exceptions.WorksheetNotFound:
                        tracking_sheet = tracking_doc.add_worksheet(title="Seguimiento", rows=100, cols=10)
                        headers = ["Nombre", "Nivel", "Fecha", "Errores Gram√°tica", "Errores L√©xico", 
                                "Errores Puntuaci√≥n", "Errores Estructura", "Total Errores", "Consejo Final"]
                        tracking_sheet.append_row(headers)
                    
                    tracking_sheet.append_row(datos_seguimiento)
                    st.success(f"‚úÖ Estad√≠sticas guardadas en hoja de Seguimiento (recuperada).")
            except Exception as e:
                st.error(f"‚ùå Error al guardar estad√≠sticas en Seguimiento: {str(e)}")
                st.info("Detalles del error para depuraci√≥n:")
                st.code(str(e))

            # --- GENERAR AUDIO CON ELEVENLABS (Consejo final en espa√±ol) ---
            st.markdown("**üîä Consejo le√≠do en voz alta (en espa√±ol):**")
            with st.spinner("Generando audio con ElevenLabs..."):
                tts_url = f"https://api.elevenlabs.io/v1/text-to-speech/{elevenlabs_voice_id}"
                headers = {
                    "xi-api-key": elevenlabs_api_key,
                    "Content-Type": "application/json"
                }
                audio_text = consejo_final.replace("Consejo final:", "").strip()
                data = {
                    "text": audio_text,
                    "model_id": "eleven_multilingual_v2",
                    "voice_settings": {
                        "stability": 0.3,
                        "similarity_boost": 0.9
                    }
                }
                try:
                    response_audio = requests.post(tts_url, headers=headers, json=data)
                    if response_audio.ok:
                        audio_bytes = BytesIO(response_audio.content)
                        st.audio(audio_bytes, format="audio/mpeg")
                    else:
                        st.warning(f"‚ö†Ô∏è No se pudo reproducir el consejo con ElevenLabs. (Status code: {response_audio.status_code})")
                except Exception as e:
                    st.warning(f"‚ö†Ô∏è Error al generar audio: {e}")

            # --- DESCARGA EN TXT ---
            feedback_txt = (
                f"Texto original:\n{texto}\n\n"
                f"Saludo:\n{saludo}\n\n"
                f"Tipo de texto:\n{tipo_texto}\n\n"
                f"Errores:\n{json.dumps(errores_obj, indent=2, ensure_ascii=False)}\n\n"
                f"Texto corregido:\n{texto_corregido}\n\n"
                f"Consejo final:\n{consejo_final}\n\n"
                f"{fin}"
            )
            txt_buffer = BytesIO()
            txt_buffer.write(feedback_txt.encode("utf-8"))
            txt_buffer.seek(0)
            st.download_button(
                label="üìù Descargar correcci√≥n en TXT",
                data=txt_buffer,
                file_name=f"correccion_{nombre}.txt",
                mime="text/plain"
            )

        except Exception as e:
            st.error(f"Error al generar la correcci√≥n o guardar: {e}")
            import traceback
            st.code(traceback.format_exc())
